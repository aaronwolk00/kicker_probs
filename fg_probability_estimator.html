<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NFL FG Probability — Coupled (Make × Attempt)</title>
<style>
  :root { --bg:#0b0f14; --card:#121820; --muted:#9fb0c3; --acc:#3da9fc; }
  * { box-sizing: border-box; }
  body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:#e6eef7; }
  .wrap { max-width:1100px; margin:24px auto; padding:0 16px; }
  .card { background:var(--card); border-radius:16px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,.25); margin-bottom:18px;}
  h1 { margin:0 0 8px 0; font-size:26px; font-weight:700; }
  h2 { margin:10px 0 12px 0; font-size:18px; color:var(--muted); }
  .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  .row { display:flex; gap:10px; align-items:center; margin:8px 0; }
  label { font-size:14px; color:var(--muted); min-width:160px; }
  input[type="number"], select { background:#0f141b; color:#e6eef7; border:1px solid #263141; border-radius:8px; padding:8px 10px; width:100%; }
  input[type="range"] { width:100%; }
  .pill { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; background:#0f141b; border:1px solid #263141; color:#9fb0c3; }
  .out { font-size:18px; }
  .muted { color:#9fb0c3; font-size:12px; }
  .svgbox { width:100%; height:220px; background:#0f141b; border:1px solid #263141; border-radius:12px; }
  .warn { color:#ffcc66; }
  .uploader { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .kmeta { font-size:12px; color:#9fb0c3; }
  @media (max-width: 960px){ .grid{grid-template-columns:1fr;} label{min-width:140px;} }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Field Goal Probability — Coupled (Coach View)</h1>
    <div class="muted">
      Make model: LGBM (monotone distance) · bagged · isotonic · bilinear (Temp×Wind).<br/>
      Kicker: recency-weighted Bayesian deltas by distance band (weaker prior at 60+).<br/>
      Attempt model: league context grid + <em>coupling</em> so Attempt% rises with kicker’s make% advantage.
    </div>
    <div id="loadMsg" class="muted"></div>
    <div class="uploader" id="fallbackUpload" style="display:none">
      <div><label class="pill">Load make grid</label><input type="file" id="fileGrid" accept=".json"/></div>
      <div><label class="pill">Load kicker banded JSON</label><input type="file" id="fileKickers" accept=".json"/></div>
      <div><label class="pill">Load attempt grid</label><input type="file" id="fileAttempt" accept=".json"/></div>
      <div><label class="pill">Load attempt sensitivity</label><input type="file" id="fileSens" accept=".json"/></div>
      <button id="btnUseUploads">Use uploaded files</button>
    </div>
  </div>

  <div class="card">
    <h2>Inputs</h2>
    <div class="grid">
      <div>
        <div class="row">
          <label>Distance (yards)</label>
          <input id="distance" type="range" min="18" max="68" step="1" value="61" oninput="uiDist.value=value; recompute()"/>
          <input id="uiDist" type="number" min="18" max="68" step="1" value="61" oninput="distance.value=value; recompute()"/>
        </div>
        <div class="row">
          <label>Environment</label>
          <select id="env" onchange="onEnvChange()">
            <option value="indoor">Indoor</option>
            <option value="outdoor" selected>Outdoor</option>
          </select>
          <span class="pill">Roof “outdoors” → Outdoor; else Indoor</span>
        </div>
        <div class="row">
          <label>Temperature (°F)</label>
          <input id="temp" type="number" value="65" step="1" oninput="recompute()"/>
          <span class="pill">Bilinear (Temp×Wind)</span>
        </div>
        <div class="row">
          <label>Wind (mph)</label>
          <input id="wind" type="number" value="5" step="1" oninput="recompute()"/>
          <span class="pill">Indoor forces 0</span>
        </div>
      </div>

      <div>
        <div class="row">
          <label>Kicker</label>
          <select id="kicker" onchange="recompute()">
            <option value="">— none —</option>
          </select>
        </div>
        <div class="row">
          <label>Context: Score</label>
          <select id="scoreBin" onchange="recompute()">
            <option value="trail">Trailing (≤ −3)</option>
            <option value="close" selected>Close (−2..+2)</option>
            <option value="lead">Leading (≥ +3)</option>
          </select>
        </div>
        <div class="row">
          <label>Context: Time (half)</label>
          <select id="timeBin" onchange="recompute()">
            <option value="early">Early (≈20:00)</option>
            <option value="mid">Mid (≈10:00)</option>
            <option value="late" selected>Late (≈2:00)</option>
          </select>
        </div>
        <div class="row">
          <label>Context: Yards to go</label>
          <select id="ytgBin" onchange="recompute()">
            <option value="short">Short (≤2)</option>
            <option value="med" selected>Medium (3–6)</option>
            <option value="long">Long (≥7)</option>
          </select>
        </div>
        <div class="row">
          <label>Confidence band</label>
          <select id="band" onchange="recompute()">
            <option value="80" selected>80% (p10–p90)</option>
            <option value="68">~68%</option>
            <option value="90">90%</option>
          </select>
        </div>
      </div>
    </div>
    <div id="kmeta" class="kmeta"></div>
  </div>

  <div class="card">
    <h2>Coach Readout</h2>
    <div id="result" class="out">—</div>
    <div id="details" class="muted">—</div>
  </div>

  <div class="card">
    <h2>Distance Profile (Make% | Attempt)</h2>
    <svg id="chart" class="svgbox" viewBox="0 0 800 220" preserveAspectRatio="none"></svg>
    <div class="muted">Curve = Make% (bilinear, with kicker banded shift). Shaded = CI. Attempt% is shown in the readout (context- and kicker-adjusted).</div>
  </div>
</div>

<script>
let GRID=null, KICKERS=[], ATTEMPT=null, SENS=null;
let gridIndex=new Map(), attemptIndex=new Map(), KMAP=new Map();
let temps=[], winds=[];

const distance  = document.getElementById('distance');
const uiDist    = document.getElementById('uiDist');
const envSel    = document.getElementById('env');
const tempInp   = document.getElementById('temp');
const windInp   = document.getElementById('wind');
const kickerSel = document.getElementById('kicker');
const bandSel   = document.getElementById('band');
const scoreBin  = document.getElementById('scoreBin');
const timeBin   = document.getElementById('timeBin');
const ytgBin    = document.getElementById('ytgBin');
const loadMsgEl = document.getElementById('loadMsg');
const kmetaEl   = document.getElementById('kmeta');
const resultEl  = document.getElementById('result');
const detailsEl = document.getElementById('details');
const chartEl   = document.getElementById('chart');

const upWrap       = document.getElementById('fallbackUpload');
const fileGrid     = document.getElementById('fileGrid');
const fileKickers  = document.getElementById('fileKickers');
const fileAttempt  = document.getElementById('fileAttempt');
const fileSens     = document.getElementById('fileSens');
const btnUseUploads= document.getElementById('btnUseUploads');

function onEnvChange(){
  if (envSel.value === 'indoor'){ windInp.value = 0; windInp.disabled = true; }
  else { windInp.disabled = false; }
  recompute();
}

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function logit(p){ p = Math.min(Math.max(p,1e-9), 1-1e-9); return Math.log(p/(1-p)); }
function sigmoid(x){ return 1/(1+Math.exp(-x)); }
function pct(x){ return (x*100).toFixed(1) + "%"; }

function buildMakeIndex(){
  gridIndex.clear();
  temps = GRID.meta.temps.slice();
  winds = GRID.meta.winds.slice();
  for(const r of GRID.grid){
    gridIndex.set(`${r.indoor_outdoor}|${r.temp_F}|${r.wind_mph}|${r.distance}`, r);
  }
}
function buildAttemptIndex(){
  attemptIndex.clear();
  for(const r of ATTEMPT.grid){
    attemptIndex.set(`${r.indoor_outdoor}|${r.score_bin}|${r.time_bin}|${r.ytg_bin}|${r.distance}`, r);
  }
}
function populateKickers(){
  KMAP.clear();
  kickerSel.innerHTML = `<option value="">— none —</option>`;
  const frag = document.createDocumentFragment();
  const sorted = [...KICKERS].sort((a,b)=> (b.attempts_eff||0) - (a.attempts_eff||0));
  for(const k of sorted){
    const opt = document.createElement('option');
    opt.value = k.kicker_id;
    opt.textContent = `${k.kicker_name || k.kicker_id} (effAtt=${(k.attempts_eff||0).toFixed(1)})`;
    frag.appendChild(opt);
    KMAP.set(k.kicker_id, k);
  }
  kickerSel.appendChild(frag);
}

function neighbors(val, arr){
  if (val <= arr[0]) return [arr[0], arr[0]];
  if (val >= arr[arr.length-1]) return [arr[arr.length-1], arr[arr.length-1]];
  for (let i=0; i<arr.length-1; i++){
    if (val >= arr[i] && val <= arr[i+1]) return [arr[i], arr[i+1]];
  }
  return [arr[0], arr[0]];
}
function nearest(val, arr){
  let best = arr[0], bd = Math.abs(val-arr[0]);
  for(const x of arr){ const d = Math.abs(val-x); if (d<bd){ bd=d; best=x; } }
  return best;
}
function lookupMake(env, temp, wind, dist){
  return gridIndex.get(`${env}|${temp}|${wind}|${dist}`) || null;
}
function interpBilinearLogit(env, temp, wind, dist){
  if (env === 'indoor') wind = 0;
  const [t0,t1]=neighbors(temp, temps), [w0,w1]=neighbors(wind, winds);
  const sameT=(t0===t1), sameW=(w0===w1);
  const r00=lookupMake(env,t0,w0,dist), r10=lookupMake(env,t1,w0,dist),
        r01=lookupMake(env,t0,w1,dist), r11=lookupMake(env,t1,w1,dist);
  if (!r00 || (!sameT && !r10) || (!sameW && !r01) || (!sameT && !sameW && !r11)){
    const tN=nearest(temp,temps), wN=(env==='indoor'?0:nearest(wind,winds));
    const r=lookupMake(env,tN,wN,dist);
    if (!r) return null;
    return {mean:r.prob_mean, lo:r.prob_p10, hi:r.prob_p90, baseMean:r.prob_mean, mode:"nearest"};
  }
  function blend(field){
    const L00=logit(r00[field]), L10=sameT?L00:logit(r10[field]);
    const L01=sameW?L00:logit(r01[field]), L11=(sameT&&sameW)?L00:logit(r11[field]);
    const wt=sameT?0:(temp-t0)/(t1-t0), ww=sameW?0:(wind-w0)/(w1-w0);
    const L0=L00*(1-wt)+L10*wt, L1=L01*(1-wt)+L11*wt;
    return sigmoid(L0*(1-ww)+L1*ww);
  }
  return {mean:blend("prob_mean"), lo:blend("prob_p10"), hi:blend("prob_p90"),
          baseMean:blend("prob_mean"), mode:"bilinear"};
}

// kicker band blending
const BAND_BOUNDS = { short:39, mid:49, long:59 };
const BLEND_W = 2;
function bandWeightsForDistance(d){
  if (d <= BAND_BOUNDS.short - BLEND_W) return {short:1};
  if (d <  BAND_BOUNDS.short + BLEND_W){ const t=(d-(BAND_BOUNDS.short-BLEND_W))/(2*BLEND_W); return {short:1-t, mid:t}; }
  if (d <= BAND_BOUNDS.mid - BLEND_W) return {mid:1};
  if (d <  BAND_BOUNDS.mid + BLEND_W){ const t=(d-(BAND_BOUNDS.mid-BLEND_W))/(2*BLEND_W); return {mid:1-t, long:t}; }
  if (d <= BAND_BOUNDS.long - BLEND_W) return {long:1};
  if (d <  BAND_BOUNDS.long + BLEND_W){ const t=(d-(BAND_BOUNDS.long-BLEND_W))/(2*BLEND_W); return {long:1-t, xlong:t}; }
  return {xlong:1};
}
function kickerShiftForDistance(krec, d){
  if (!krec || !krec.bands) return {delta:0, se:0};
  const w=bandWeightsForDistance(d); let delta=0, var_sum=0, wsum=0;
  for (const band of Object.keys(w)){
    const ww=w[band], b=krec.bands[band];
    if (!b) continue;
    const dlt=(typeof b.delta_logit==="number")?b.delta_logit:0;
    const se=(typeof b.se==="number")?b.se:0;
    delta += ww*dlt; var_sum += (ww*ww)*(se*se); wsum += ww;
  }
  if (wsum<=0) return {delta:0,se:0};
  return {delta, se:Math.sqrt(var_sum)};
}

function ciScale(band){
  if (band===80) return 1.0;
  if (band===68) return 0.68/0.80;
  if (band===90) return 0.90/0.80;
  return 1.0;
}

function lookupAttempt(env, sBin, tBin, yBin, dist){
  return attemptIndex.get(`${env}|${sBin}|${tBin}|${yBin}|${dist}`) || null;
}

function recompute(){
  if (!GRID || !ATTEMPT || !SENS) return;

  const d = clamp(parseInt(distance.value,10), 18, 68); uiDist.value = d;
  const env  = envSel.value;
  const temp = parseFloat(tempInp.value);
  const wind = parseFloat(windInp.value) || 0;
  const band = parseInt(bandSel.value,10);

  // Base league make (no kicker)
  const base = interpBilinearLogit(env, temp, wind, d);
  if (!base){ resultEl.textContent="No data"; detailsEl.textContent=""; kmetaEl.textContent=""; drawChart(env,temp,wind,d); return; }
  let pMakeLeague = base.baseMean; // before kicker
  let pMean = base.mean, pLo = base.lo, pHi = base.hi;

  // Kicker adjust in logit space
  const kid = kickerSel.value;
  let kmeta = "", delta=0, se=0;
  if (kid){
    const krec = KMAP.get(kid);
    const ks = kickerShiftForDistance(krec, d);
    delta = ks.delta; se = ks.se||0;
    pMean = sigmoid(logit(pMean) + delta);
    pLo   = sigmoid(logit(pLo)   + delta);
    pHi   = sigmoid(logit(pHi)   + delta);
    if (se>0){ pLo = sigmoid(logit(pLo)-se); pHi = sigmoid(logit(pHi)+se); }
    const bands = Object.keys(krec?.bands||{}).join(", ");
    kmeta = `Kicker: ${krec?.kicker_name || kid} · effAtt=${(krec?.attempts_eff||0).toFixed(1)} · bands=[${bands}] · Δlogit(d)=${delta.toFixed(3)}`;
  }
  kmetaEl.textContent = kmeta;

  // Rescale CI to selected band
  const lmean = logit(pMean), scale = ciScale(band);
  let llo = logit(pLo), lhi = logit(pHi), half=(lhi-llo)/2;
  llo = lmean - half*scale; lhi = lmean + half*scale;
  pLo = sigmoid(llo); pHi = sigmoid(lhi);

  // Attempt base (league context)
  const sBin = scoreBin.value, tBin = timeBin.value, yBin = ytgBin.value;
  const rA = lookupAttempt(env, sBin, tBin, yBin, d);
  const pAttemptBase = rA ? rA.prob_attempt_mean : 0.0;
  const pAttemptBase_lo = rA ? rA.prob_attempt_p10 : 0.0;
  const pAttemptBase_hi = rA ? rA.prob_attempt_p90 : 0.0;

  // Attempt adjusted by kicker advantage (coupling)
  const A=SENS.A, B=SENS.B, C=SENS.C;
  const lA = A + C*logit(pAttemptBase) + B*(logit(pMean) - logit(pMakeLeague));
  const pAttemptAdj = sigmoid(lA);

  // Overall chance to get 3 points
  const pOverall = pAttemptAdj * pMean;

  resultEl.innerHTML = `
    <div><strong>Make | Attempt</strong>: ${pct(pMean)} <span class="muted">(CI ${band}%: ${pct(pLo)}–${pct(pHi)})</span></div>
    <div><strong>Attempt % (base)</strong>: ${pct(pAttemptBase)} <span class="muted">(p10–p90: ${pct(pAttemptBase_lo)}–${pct(pAttemptBase_hi)})</span></div>
    <div><strong>Attempt % (kicker-adjusted)</strong>: ${pct(pAttemptAdj)}</div>
    <div><strong>Overall Make %</strong>: ${pct(pOverall)}</div>
  `;

  const wShow = env==='indoor'?0:wind;
  detailsEl.textContent = `Inputs: ${d} yd, ${env}, ${Math.round(temp)}°F, wind ${Math.round(wShow)} mph · Score=${sBin}, Time=${tBin}, YTG=${yBin} · ${base.mode}`;

  drawChart(env, temp, wind, d);
}

function drawChart(env, temp, wind, dSel){
  const W=800,H=220,PAD=34;
  const xs=[], meanYs=[], loYs=[], hiYs=[];
  for(let d=18; d<=68; d++){
    const r = interpBilinearLogit(env, temp, wind, d);
    if(!r) continue;
    xs.push(d); meanYs.push(r.mean); loYs.push(r.lo); hiYs.push(r.hi);
  }
  const kid = kickerSel.value;
  if (kid){
    const krec = KMAP.get(kid);
    for(let i=0;i<xs.length;i++){
      const ks = kickerShiftForDistance(krec, xs[i]);
      meanYs[i] = sigmoid(logit(meanYs[i]) + ks.delta);
      loYs[i]   = sigmoid(logit(loYs[i])   + ks.delta - (ks.se||0));
      hiYs[i]   = sigmoid(logit(hiYs[i])   + ks.delta + (ks.se||0));
    }
  }

  const xmin=18,xmax=68,ymin=0,ymax=1;
  const sx=x=>PAD+(x-xmin)/(xmax-xmin)*(W-2*PAD);
  const sy=y=>H-PAD-(y-ymin)/(ymax-ymin)*(H-2*PAD);
  const path=(xs,ys)=>xs.map((x,i)=>`${i?'L':'M'} ${sx(x).toFixed(1)} ${sy(ys[i]).toFixed(1)}`).join(' ');
  const meanPath=path(xs,meanYs), loPath=path(xs,loYs), hiPath=path(xs,hiYs);
  const bandPath = meanYs.length?(()=>{
    const up=xs.map((x,i)=>`${i?'L':'M'} ${sx(x).toFixed(1)} ${sy(hiYs[i]).toFixed(1)}`).join(' ');
    const dn=xs.slice().reverse().map((x,i)=>`L ${sx(x).toFixed(1)} ${sy(loYs[loYs.length-1-i]).toFixed(1)}`).join(' ');
    return `${up} ${dn} Z`;
  })() : "";
  const xd = sx(dSel);

  chartEl.innerHTML = `
    <rect x="0" y="0" width="${W}" height="${H}" fill="#0f141b"/>
    <g stroke="#1f2a38" stroke-width="1" opacity="0.8">
      ${[0.2,0.4,0.6,0.8].map(p=>`<line x1="${PAD}" x2="${W-PAD}" y1="${sy(p)}" y2="${sy(p)}"></line>`).join('')}
    </g>
    <path d="${bandPath}" fill="#3da9fc22" stroke="none"></path>
    <path d="${meanPath}" fill="none" stroke="#3da9fc" stroke-width="2"></path>
    <path d="${loPath}"   fill="none" stroke="#3da9fc55" stroke-width="1"></path>
    <path d="${hiPath}"   fill="none" stroke="#3da9fc55" stroke-width="1"></path>
    <line x1="${xd}" x2="${xd}" y1="${PAD}" y2="${H-PAD}" stroke="#ffcc66" stroke-width="2" stroke-dasharray="4 4"></line>
  `;
}

// ---- loading with serverless fallback ----
async function tryFetch(url){ const r=await fetch(url); if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }
function readFileAsJSON(input){ return new Promise((res,rej)=>{ if(!input.files||!input.files[0]) return rej(new Error("No file"));
  const fr=new FileReader(); fr.onload=()=>{ try{res(JSON.parse(fr.result))}catch(e){rej(e)} }; fr.onerror=()=>rej(fr.error); fr.readAsText(input.files[0]); }); }

async function boot(){
  try{
    loadMsgEl.textContent = "Loading JSONs via fetch…";
    GRID    = await tryFetch("./fg_prob_grid_distance_env_temp_wind.json");
    KICKERS = await tryFetch("./kicker_deltas_logit_banded.json");
    ATTEMPT = await tryFetch("./fg_attempt_grid_distance_env_context.json");
    SENS    = await tryFetch("./attempt_sensitivity.json");
    loadMsgEl.textContent = "Loaded via fetch.";
    afterLoad();
  }catch(e){
    console.warn("Fetch failed:", e);
    loadMsgEl.innerHTML = `<span class="warn">Fetch failed (likely file:// CORS). Upload the four JSONs below or run a local server.</span>`;
    document.getElementById('fallbackUpload').style.display = "flex";
    btnUseUploads.onclick = async ()=>{
      try{
        GRID    = await readFileAsJSON(fileGrid);
        KICKERS = await readFileAsJSON(fileKickers);
        ATTEMPT = await readFileAsJSON(fileAttempt);
        SENS    = await readFileAsJSON(fileSens);
        loadMsgEl.textContent = "Loaded via file uploads.";
        document.getElementById('fallbackUpload').style.display = "none";
        afterLoad();
      }catch(err){
        loadMsgEl.innerHTML = `<span class="warn">Upload parse error: ${err.message}</span>`;
      }
    };
  }
}
function afterLoad(){
  buildMakeIndex();
  buildAttemptIndex();
  populateKickers();
  onEnvChange();
  recompute();
}
boot();
</script>
</body>
</html>
